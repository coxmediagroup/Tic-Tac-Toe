<!DOCTYPE html>
<html>
<head>
    <title>Heads of State</title>
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0;" />
    <link rel="stylesheet" type="text/css" href="appframework/af.ui.css" />
    <link rel="stylesheet" type="text/css" href="appframework/icons.css" />
    <script type="text/javascript" charset="utf-8" src="appframework/appframework.ui.min.js"></script>

	<!-- Used for giving app access to native phone features -->    
	<script src="intelxdk.js"></script>
	<script src="xhr.js"></script>
	<script>    
		function onDeviceReady(){ 
			$.ui.launch();
			intel.xdk.device.hideSplashScreen();
		}
		document.addEventListener("intel.xdk.device.ready", onDeviceReady, false);
	</script>
	<!-- Used for giving app access to native phone features --> 
    
    <script>   
        $.ui.autoLaunch = false; 
        $.ui.animateHeaders = false;
                
        $(document).ready(function(){
            $.ui.launch();
        });
    </script>    

	<!-- ~~~~~~~~~~~~Knockout~~~~~~~~~~~~ -->
	<script src="http://cdnjs.cloudflare.com/ajax/libs/knockout/2.3.0/knockout-min.js" ></script>
	
	<style>
		body, #afui {background-color:#000}  
		#afui #settingsList.list li {padding: 10px}       


		#play_as input.toggle:checked + label > span {
			transform: translate3d(58px, 0px, 0px);
		}

		#play_as input.toggle + label:before, #play_as input.toggle:checked + label:before {
		 width: 50px;
		}

		table
		{
		border-collapse:collapse;
		 margin: 0 auto;
		}
		
		table, td, th {
			border:5px solid black;
			width: 250px;
			height: 100px;
		}

		.enabled {
			cursor:pointer;
		}
		
		.enabled:hover, .enabled:focus {
			background-color: rgb(0,136,209);
		}
		
		.notShown{
			visibility:hidden;
		}
		.shown{
			visibility:visible;
		}
		#turnMessage{
			text-align:center;
			padding:20px;
			font-weight:bold;
			font-size:300%; 
		}
		.humanTurnMessage{
			text-shadow:2px	2px 3px black, 3px 7px 30px blue;	
		}
		.computerTurnMessage{
			text-shadow:2px	2px 3px black, 3px 7px 30px red;	
		}
	</style>   
	
</head>
<body> 
	<div id="afui">
		<div id="content" >
			
			<!-- ~~~~main panel~~~~~ -->
			<div class="panel" title="Title" id="main"  selected="true">
				<header>
					<h1>Heads of State: Tic Tac Toe</h1>
					<a href="#backpage" data-transition="up" class="button icon settings" style="float:right"></a>
				</header>
				
				<div id="turnMessage" data-bind="text: vm.turnNotifier, attr:{'class': vm.turnMessageStyle() }"></div>
				<table>
					<tbody>
						<tr data-bind="foreach: vm.table.grids.slice(0, 3)">
							<td data-bind="click:userClicked , attr:{'class': enabled() }">
								<img data-bind="attr:{'src': image, 'class': imageClass() }" height="80" width="80">					
							</td>
						</tr>	
						<tr data-bind="foreach: vm.table.grids.slice(3, 6)">
							<td data-bind="click:userClicked , attr:{'class': enabled() }">
								<img data-bind="attr:{'src': image, 'class': imageClass() }" height="80" width="80"> 
							</td>
						</tr>
						<tr data-bind="foreach: vm.table.grids.slice(6, 9)">
							<td data-bind="click:userClicked , attr:{'class': enabled() }">
								<img data-bind="attr:{'src': image, 'class': imageClass() }" height="80" width="80"> 
							</td>
						</tr>						
					</tbody>
				</table>	
			</div>
			<!-- ~~~~main panel~~~~~ -->
			
			<!-- ~~~~settings panel~~~~~ -->
			<div class="panel" title="Settings" id="backpage"  >
				<header>
					<h1>Settings</h1>
					<a onclick="$.ui.goBack();" class="button icon close" style="float:right"></a>
				</header>
				<div style="height:30px;"></div>
				
				<ul class="list inset" id="settingsList">
					<li>
						<label>Play As</label>
						<div id="play_as">
							<input onchange="vm.toggleSelectedCharacter()" id="toggle1" type="checkbox" name="toggle1" class="toggle" checked>
							<label style="left:70%; width:85px" for="toggle1" data-on="Obama" data-off="Putin">
								<span ></span>
							</label>
						</div>
					</li>
					<li>
						<label>Sound</label>
						<input id="toggle2" type="checkbox" name="toggle2" class="toggle"><label style="left:70%" for="toggle2" data-on="On" data-off="Off"><span></span></label>
					</li>
				</ul> 
			</div>
			<!-- ~~~~settings panel~~~~~ -->
			
			
		</div>
		
            <div id="navbar">
                <a href="#main" class='icon refresh' onclick="vm.resetTable()" >Start Over</a>			
            </div>		
	</div>
	
	<script>
	
	ko.bindingHandlers.valueFirstText =
	{
		/*
			This function replaces only the first child. Not all the children
			as the current text binding does. function must occur before view model is instantiated
		*/
		init: function(element, valueAccessor, allBindings, viewModel, bindingContext)
		{
		   var valueBeingBinded = ko.unwrap(valueAccessor());
		   element.replaceChild(document.createTextNode(valueBeingBinded), element.firstChild);
		},
		update: function(element, valueAccessor, allBindings, viewModel, bindingContext)
		{

		   var valueBeingBinded = ko.unwrap(valueAccessor());
		   element.replaceChild(document.createTextNode(valueBeingBinded), element.firstChild);
		}
	};	
	
		/*
			0	= not selected
			1 	= selected by player
			-1	= selected by computer	
		*/
		
		function grid(x,y, indexInGridsArray, app_parent) {
			var self = this;
			
			self.x				= x;
			self.y				= y;
			self.value 			= ko.observable(0);	
			self.index			= indexInGridsArray;
			
			self.value.subscribe(function(newValue) {
			
				if( newValue === 1) {
					app_parent.humanIsFreeToSelect = false;
					app_parent.computer.humanPlays.push(self.index);
					app_parent.switchTurns();
				} else if( newValue === -1) {
					app_parent.computer.computerPlays.push(self.index);	
					app_parent.switchTurns();					
				}				
			});
			
			self.userClicked= function() {
				if(app_parent.humans_turn() && self.value() === 0 && app_parent.humanIsFreeToSelect){
					self.value(1);
				}
			}		
			
			self.imageClass = ko.computed(function(){
				//hides image tag when there's no image
			
				if(self.value() === 0) {
					return 'notShown';
				} else {
					return 'shown';
				}
			
			});
			
			self.image 	= ko.computed(function() {

					//sets the image for grid
					if( self.value() === 0 ){
					
						return '';				
					}else if( self.value() === 1){
					
						if( app_parent.play_as() === 'obama') {
							return 'static/images/obama.png';
						}else {
							return 'static/images/putin.png';
						}					
					}else if( self.value() === -1){
				
						if( app_parent.play_as() === 'obama') {
							return 'static/putin.png';
						}else {
							return 'static/obama.png';
						}
					}

				});
			
			self.enabled 	= ko.computed(function() {
					//enable grid if its the players turn and grid is not yet selected
					if( app_parent.humans_turn() === true && self.value() === 0 ){
						return 'enabled';				
					}else{
						return '';
					}
				});	


			

		}	

		
		function table(app_parent) {
			var self 	= this;
			
			/*
				the information stored in grids is used to render the 
				spatial layout of all the grids in the table
			*/
			self.grids	= [];

			//---------------------creates grids in table
			self.grids.push( new grid(0,0,0, app_parent) );
			self.grids.push( new grid(1,0,1, app_parent) );
			self.grids.push( new grid(2,0,2, app_parent) );
			
			self.grids.push( new grid(0,1,3, app_parent) );
			self.grids.push( new grid(1,1,4, app_parent) );
			self.grids.push( new grid(2,1,5, app_parent) );
			
			self.grids.push( new grid(0,2,6, app_parent) );
			self.grids.push( new grid(1,2,7, app_parent) );
			self.grids.push( new grid(2,2,8, app_parent) );			
			//---------------------creates grids in table	
		}
		
		function computersLogic(app_parent) {
			/*
				This object represents the brain or mind of the computer.
				It describes how the computer sees or perceives the grid and how it makes its decisions
				about which grid to play.
			*/
				
			var self = this;
			
			/*
				mind of computer stores the location of the center, corners, edges in the table.grids array.
				This is how the computer perceives the tic tac toe grid. With this level of abstraction, the 
				computer can make intelligent decisions to win or tie the game
			*/
			
			self.center 	= [4];
			self.corners	= [0, 2, 6, 8];
			self.edges		= [1, 3, 7, 5];		
			
			//this is how long the computer takes to make a decision
			self.decideTime	= 2000;
			
			self.computerPlays		= [];
			self.humanPlays			= [];
			
			self.strategy;
			
			//there are 8 different ways to win, 3 columns, 3 rows and 2 diagonals
			self.winningGridCombinations	= [[0,3,6],[1,4,7],[2,5,8],[0,1,2],[3,4,5],[6,7,8],[0,4,8],[2,4,6]];
			
			self.randomNumberBetweenZeroAndN	= function(n) {
			
				//this will help the computer choose a random number
				return randomnumber=Math.floor(Math.random()*(n+1)) ;
			}
			
			
			self.getLastItemInArray		= function(array) {
				return array[array.length - 1];
			}
			
			
			self.classifyPlayType	= function(playSelection) {

				result = self.center.indexOf(playSelection);
				if( result !== -1) {
					return 'center';
				}
				
				result = self.corners.indexOf(playSelection);
				if( result !== -1) {
					return 'corner';
				}
				
				result = self.edges.indexOf(playSelection);
				if( result !== -1) {
					return 'edge';
				}
		
			}
			
			self.sharesSideWith		= function(gridA, gridB)
			{
				
				//function returns true if grid A shares side with grid B
				
				if (gridA.x === gridB.x) 
				{
					if (gridA.y === (gridB.y + 1) || gridA.y === (gridB.y - 1) )
					{
						//gridA and girdB share a horizontal edge
						return true;
					}
						
				} else if(gridA.y === gridB.y) 
				{
					if (gridA.x === (gridB.x + 1) || gridA.x === (gridB.x - 1) ) 
					{
						//gridA and girdB share a vertical edge
						return true;
					}
				}
				return false;
			}
			
			
			self.isDiagonalWith	= function(gridA, gridB)
			{
				
				//function returns true if grid A is on the  opposite diagonal of grid B
				//if the deltax and deltay = width of the row, then the two elements are opposite diagonals

				if(  ( Math.abs(gridA.x - gridB.x) === 2) &&  (Math.abs(gridA.y - gridB.y) === 2) ) {
					return true;
				}
				return false;
			}				
				
			
			
			self.makeFirstPlayAttackMode = function() {
			
				//computer uses random number to choose strategy
				var technique = self.randomNumberBetweenZeroAndN(1);
				
				if( technique === 0 ) {
					//select center
					app_parent.table.grids[ self.center[0] ].value(-1);
					
					
				} else {
					//select a corner randomly
					
					corner = self.randomNumberBetweenZeroAndN(3);
					app_parent.table.grids[ self.corners[corner] ].value(-1);
				}							
				
			}
			
			self.makeSecondPlayAttackMode = function() {
			
				//find out what move the human last made
				humanPreviousPlayIndex 		= self.getLastItemInArray( self.humanPlays );
				
				//classify humans last play
				humanPreviousPlayType 	= self.classifyPlayType(humanPreviousPlayIndex);
				
				//uses humanPreviousPlayIndex to find the last actual grid selected
				lastGridHumanSelected 	= app_parent.table.grids[ humanPreviousPlayIndex ];
				
				computerPreviousPlayIndex	= self.getLastItemInArray( self.computerPlays );  
				lastGridComputerSelected 	= app_parent.table.grids[ computerPreviousPlayIndex ];
				
				
				if( humanPreviousPlayType === 'edge') {
					//the computer will select a corner which does not share a side with the human's previous play
					
					nonSideSharingCorners = [];
					for(i=0; i< self.corners.length; i++) {
					
						if( app_parent.table.grids[ self.corners[i] ].value() !== 0) {
							//if grid has been selected, then skip it
							continue;
						}
					
						localGrid = app_parent.table.grids[ self.corners[i] ];
						if( self.sharesSideWith(lastGridHumanSelected, localGrid) === false ) {
							nonSideSharingCorners.push(self.corners[i]);
						}
					}
					
					
					//if center is not taken, then choose corner that is not diagonal to the the computers 1st selection
					if (app_parent.table.grids[4].value() ===0) {
						
						for(i=0; i<nonSideSharingCorners.length; i++) {
							localGrid = app_parent.table.grids[ nonSideSharingCorners[i] ];
							
							if( self.isDiagonalWith(lastGridComputerSelected, localGrid) === false ) {
								selectedCornerIndex = nonSideSharingCorners[i];
								break;
							}
						}
						
							//computer takes the index and uses it to select a corner
							app_parent.table.grids[ selectedCornerIndex ].value(-1);	
							
					} else {
					
						//computer randomly chooses a corner from the non sharing side corners
						selectedCornerIndex = self.randomNumberBetweenZeroAndN(nonSideSharingCorners.length - 1);
						
						//computer takes the index and uses it to select a corner
						app_parent.table.grids[ nonSideSharingCorners[selectedCornerIndex] ].value(-1);						
						
					}
					

					

				}else if (humanPreviousPlayType === 'center') {
					//the computer will select the corner opposite from its previous selection
					
					var diagonalCorner;
					
					for(i=0; i< self.corners.length; i++) {
					
						if( app_parent.table.grids[ self.corners[i] ].value() !== 0) {
							//if grid has been selected, then skip it
							continue;
						}
					
						localGrid = app_parent.table.grids[ self.corners[i] ];
						if( self.isDiagonalWith(lastGridComputerSelected, localGrid) ) {
							diagonalCorner = self.corners[i];
							break;
						}
					}
					
					//computer takes the index and uses it to select a corner
					app_parent.table.grids[ diagonalCorner ].value(-1);
					
				
				}else if (humanPreviousPlayType === 'corner') {
				
					//computer will select from the non-diagonal corners
					nonDiagonalCorners = [];
					
					for(i=0; i< self.corners.length; i++) {
					
						if( app_parent.table.grids[ self.corners[i] ].value() !== 0) {
							//if grid has been selected, then skip it
							continue;
						}
					
						localGrid = app_parent.table.grids[ self.corners[i] ];
						if( self.isDiagonalWith(lastGridHumanSelected, localGrid) === false ) {
							nonDiagonalCorners.push(self.corners[i]);
						}
					}
					//computer randomly chooses a corner from the non sharing side corners
					selectedCornerIndex = self.randomNumberBetweenZeroAndN(nonDiagonalCorners.length - 1);
					
					//computer takes the index and uses it to select a corner
					app_parent.table.grids[ nonDiagonalCorners[selectedCornerIndex] ].value(-1);
					
				}
			
			}
			
			self.makeSecondPlayAttackModeForCornerCornerDiagonal = function(){
				//returns true if situation meets criteria and computer is able to select
				
				if( self.computerPlays.length === 2) {
					//checks to see if first two computer selections were corners
					computerIndex0	= self.computerPlays[0];  
					computerIndex1	= self.computerPlays[1];  
					
					computerIndexType0 	= self.classifyPlayType(computerIndex0);
					computerIndexType1 	= self.classifyPlayType(computerIndex1);
					
					if(computerIndexType0 === 'corner' && computerIndexType1 === 'corner'){
					
						acceptValue = true;
					
						for(i=0; i< self.corners.length; i++) {

							corner = self.corners[i];	
							localCornerGrid	= 	app_parent.table.grids[ corner ];
							gridValue	=	app_parent.table.grids[ corner ].value();					
							
							if(gridValue ===0) {
								//corner has not been chosen yet
								
								for(j=0; j< self.humanPlays.length; j++) {
								
									//uses humanPreviousPlayIndex to find the last actual grid selected
									localHumanGrid 	= app_parent.table.grids[ j ];
									
									if(self.sharesSideWith(localHumanGrid, localCornerGrid)) {
										acceptValue = false;
									}
								
								}	
								
								if(acceptValue === true) {
									app_parent.table.grids[ corner ].value(-1);
									return true;
								}
							
							}
						}
					}

				}
				return false;				
			}
			
			
			self.makeFirstPlayDefenseMode = function() {
				//find out what move the human last made
				humanPreviousPlayIndex 		= self.getLastItemInArray( self.humanPlays );
				//classify humans last play
				humanPreviousPlayType 	= self.classifyPlayType(humanPreviousPlayIndex);
				
				if (humanPreviousPlayType === 'center' ) 
				{
					//the computer will select any corner 
					selectedCornerIndex = self.randomNumberBetweenZeroAndN( self.corners.length - 1);
					
					//computer takes the index and uses it to select a corner
					app_parent.table.grids[ self.corners[selectedCornerIndex] ].value(-1);
				} else if (humanPreviousPlayType === 'corner' || humanPreviousPlayType === 'edge' ) {
				
					//when opponent selects corner, select the center
					app_parent.table.grids[ 4 ].value(-1);				
				}
			}
			
			
			self.makeSecondPlayDefenseMode = function() {	
				
				//find out what move the human currently made
				humanPreviousPlayIndex 		= self.getLastItemInArray( self.humanPlays );

				computerPreviousPlayIndex 		= self.getLastItemInArray( self.computerPlays );
				//classify humans current play
				computerPreviousPlayType 	= self.classifyPlayType(computerPreviousPlayIndex);				

						

				if(  ([0,2,6,8].indexOf(humanPreviousPlayIndex) !== -1) && computerPreviousPlayType === 'center' ) {
					//this is a "corner corner-diagonal" situation
					
					if(self.steadyStateAlgorithm()) {}
					else{
						self.selectRemainingEdges();
					}					
				} else {
				
					//for all other situations:
					//the computer will select something to block opponent or select a corner
					if(self.steadyStateAlgorithm()) {}
					else{
						self.selectRemainingCorners();
					}				
				}

			
			}			
			
			self.selectRemainingCorners = function() {
				//function returns true if it selected grid and false otherwise			
				//computer tries to select any unselected corners first
				for(i=0; i< self.corners.length; i++) {
					corner = self.corners[i];
					gridValue	=	app_parent.table.grids[ corner ].value();
					
					if(gridValue === 0) {
						//corner has not been choosen yet
						
						//select corner and return
						app_parent.table.grids[ corner ].value(-1);
						return true;
					}
				}
				return false;
			}

			self.selectRemainingEdges = function() {
				//function returns true if it selected grid and false otherwise
				//computer tries to select any unselected edges after,
				//note that at this point, the center would have already been selected
				for(i=0; i< self.edges.length; i++) {
					edge = self.edges[i];
					gridValue	=	app_parent.table.grids[ edge ].value();
					
					if(gridValue === 0) {
						//edge has not been choosen yet
						
						//select edge and return
						app_parent.table.grids[ edge ].value(-1);
						return true;
					}
				}
				return false;
			}
			
			
			self.findMissingElements = function(winningArray, negationValue) {
				/*
					function returns an array of grids not yet clicked on
					but if that array has a value of negationValue, the entire row has to be negated
				*/
				
				missingElements = [];
				for(j=0; j<winningArray.length; j++) {

					gridValue	=	app_parent.table.grids[ winningArray[j] ].value();
					if( gridValue === 0) {
						
						missingElements.push(winningArray[j]);
					} else if(gridValue === negationValue) {
						return [];
					}
				}
				return missingElements;
			}
			
			self.returnElementNeededToWin = function(negationValue){
				//function returns the index (in app.table.grids) of the element needed to win or false if there is none
				for(i=0; i<self.winningGridCombinations.length; i++) {

					missingElements = self.findMissingElements(self.winningGridCombinations[i], negationValue);
					if(missingElements.length == 1) {
						//there is only one more element in this winning combination that is needed to win
						//return the index of that element
						return missingElements[0];
					}
				}
				
				//In all winning combinations, there is more than one element needed to win
				return false;
			}
			
			
			
			self.steadyStateAlgorithm = function() {
				//function returns true if it selected grid and false otherwise
			
				//check to see if computer can win the game
				computerIndex = self.returnElementNeededToWin(1);
				humanIndex = self.returnElementNeededToWin(-1);
				
				if(computerIndex !== false) {
					//computer selects last item it needs to win
					app_parent.table.grids[ computerIndex ].value(-1);
					return true;					
					
				} else if(humanIndex !== false){
					//computer blocks user by selecting item she needs to win
					app_parent.table.grids[ humanIndex ].value(-1);
					return true;
				} 
				
				return false;
				

			
			}
	
		
		}
		
		function app() {
			var self				= this;
			self.play_as 			= ko.observable('obama');	
		
			
			//----------------------------choose first turn
			/*
				humanIsFreeToSelect is used because without it, as the app is waiting to change turns,
				the human can select more than one grid
			 */
			
			if (Math.random() <= 0.5) {
				self.humans_turn 		= ko.observable(true);
				self.humanIsFreeToSelect= true;
				self.turnMessageStyle	= ko.observable('humanTurnMessage');	
			} else {
				self.humans_turn 		= ko.observable(false);
				self.humanIsFreeToSelect= false;
				self.turnMessageStyle	= ko.observable('computerTurnMessage');	
			}
			//----------------------------choose first turn			

			self.table	= new table(self);
			self.isOkayToReset = true;
			
			self.resetTable		= function() {
			
				if(self.isOkayToReset) {
					self.isOkayToReset = false;
					//function sets the value of all grids to 0
					for(i=0; i< self.table.grids.length; i++) {
						self.table.grids[i].value(0);
					}
					
					//toggles the turn, so the other player can play
					self.humans_turn( !self.humans_turn() );
					self.initializeApp();
					self.computer.computerPlays = [];
					self.computer.humanPlays = [];	
				}				
			}

			self.turnNotifier 	= ko.computed(function() {
			
					//gives the user feedback on who's turn it is
					if( self.humans_turn () === true ){
						self.turnMessageStyle('humanTurnMessage');	
						return "Your Play";				
					}else{
						self.turnMessageStyle('computerTurnMessage');	
						return "Opponent Play";
					}
				});	

			self.toggleSelectedCharacter	= function() {
				if(self.play_as() === 'obama') {
					self.play_as('putin');
				} else {
					self.play_as('obama');
				}
			}
			
			
			self.computer	= new computersLogic(self);
			
			self.initializeApp = function(){
				if( self.humans_turn() === false) {
					//------------------------when computer takes the first turn
					self.computer.strategy = 'attack';
					setTimeout(function(){
						//computer takes the index and uses it to select a corner
						self.computer.makeFirstPlayAttackMode();
					},self.computer.decideTime);	
					//-------------------------when computer takes the first turn				
				} else {
					self.computer.strategy = 'defend';
				}			
			}
			
			self.initializeApp();
			

			
			self.switchTurns = function() {
			
				setTimeout(function(){
					
					self.humans_turn(!self.humans_turn());
					
					//now when it is the humans turn, she can select again
					self.humanIsFreeToSelect = true;
					self.isOkayToReset = true;
					
					if(self.humans_turn()=== false) {
						if( self.computer.strategy === 'attack') {
						
							if(self.computer.computerPlays.length===1) {
								//when the computer has made one play already
								self.computer.makeSecondPlayAttackMode();
							} else if( self.computer.makeSecondPlayAttackModeForCornerCornerDiagonal() ){
								//this is for making the corner-corner diagonal better
							}else {
								//when the computer has made more than 2 moves with the attack strategy
								if(self.computer.steadyStateAlgorithm()) {}
								else if(self.computer.selectRemainingCorners()) { }
								else if(self.computer.selectRemainingEdges()) { }	
								}
								
						} else {
						
						
							if(self.computer.computerPlays.length===0) {
								self.computer.makeFirstPlayDefenseMode();
								
							} else if(self.computer.computerPlays.length===1) {
								self.computer.makeSecondPlayDefenseMode();
							} else {
								//when the computer has made more than 2 moves with the defense strategy
								
								if(self.computer.steadyStateAlgorithm()) {}
								else if(self.computer.selectRemainingCorners()) { }
								else if(self.computer.selectRemainingEdges()) { }								

							}
						}
					}					
					
				},1500);

			
			}
			

					
		}
		
		var vm = new app();

		ko.applyBindings(vm);	

	</script>
	
</body>
</html>    











